# Функция для ввода данных пользователем с клавиатуры
def reading_entering(n):
    matrix = []
    for i in range(n):
        temp = []
        for j in range(n):
            temp.append(float(input('enter the number of matrix ')))
        matrix.append(temp)
    return matrix


# Функция для случайной генерации весовой матрицы
def reading_random(border, nrows):
    import numpy as np
    matrix = np.random.randint(border, size=(nrows, nrows))
    return matrix

#даём пользователю выбрать способ генерации матрицы

print('Выберите способ задания весовой матрицы')
print('1. Ввод с клавиатуры')
print('2. Рандомная матрица')
type = int(input('Введите способ задания матрицы, выбрав соответствующий номер '))

if type == 1:
    n = int(input('введите размерность матрицы '))
    matrix = reading_entering(n)
    print('Ваша матрица - ')
    for i in range(n):
        print(matrix[i])
elif type == 2:
    bord = int(input('введите верхнюю границу ограничения промежутка '))
    n = int(input('введите размерность матрицы '))
    matrix = reading_random(bord, n)
    print('Ваша матрица - ', matrix)
else:
    print('ошибка! неверный выбор')


import math

#создаём функцию, в которой реализуем цикл, который выполняется пока мы не придём из вершины (u) в вершину (v), то есть в нужную нам вершину
#смысл функции в том, чтобы пройти все промежуточные точки (если таковые имеются) и вернуться в начальную точку

def get_path(P, u, v):
    path = [u] #записываем конечную вершину
    while u != v:
        u = P[u][v] #коллекция, которая содержит промежуточные вершины, через которые нам нужно пройти
        path.append(u) #добавляем номер промежуточной вершины

    return path


V = matrix



#Как и в алгоритме дейкстры будем рассматривать матрицу, как список списков 


N = len(V)                       #  определяем число вершин в графе
P = [[v for v in range(N)] for u in range(N)]       # начальный список предыдущих вершин, с помощью которого будем определять кратчайший маршрут

# алгоритм флойда

for k in range(N): #рассматриваем построчно списки
    for i in range(N): # перебираем все вершины
        for j in range(N): #перебираем все вершины ещё раз для рассмотра дополнительной точки и создания новго маршрута
#если позволяем маршруту проходить через дополнительную вершину K и этот маршрут оказывается меньше, чем уже прописанный маршрут,
# то мы заменяем его новым значением (d)

            d = V[i][k] + V[k][j]
            if V[i][j] > d:
                V[i][j] = d
                P[i][j] = k     # записываем номер промежуточной вершины, через которую нужно пройти от i к j, если выполняется условие

# нумерацця вершин начинается с нуля
#задаём данные начала и конца пути

start = int(input('Введите точку, с которой хотите начать маршрут: '))
end = int(input('Введите точку, в которой хотите окончить маршрут: '))

#Выводим конечный маршрут
print("Итоговый кратчайший маршрут по алгоритму Флойда: ",get_path(P, end, start))
